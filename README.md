
Throughout my four years at St. Thomas, I have had the opportunity to work on and learn about various projects both inside computer science and outside in other fields. I have learned various programming languages, skills, and concepts that will be useful in the coming future. Here are some of those projects that have helped facilitate growth in my education.

Project 1: Pipeline Simulator - https://github.com/gudo1013/gudo1013/blob/f53e83edab736a8d2ef165dfe588f34d5fff268c/pipeline-simulator/README.md
 
The first project to highlight is from my Computer Architecture class. We were tasked with creating a pipelining simulator to mimic how a CPU may handle multiple instructions at a time. To contextualize this project, my partner Scott D. and I built this project after completing a multi-cycle CPU simulator as our previous project. With a basic understanding of how to simulate a CPU, the next task was to create a pipelining implementation. To explain what we had to accomplish, the idea of pipelining is to have a constant flow of instructions occuring at different stages. For example, in our implementation, each instruction had 5 stages that it had to go through: Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB). Each cycle would move an instruction further down the stages until it all instructions were completed. Additionally, as one instruction moved forward, from IF to ID for example, another instruction would load in behind it, into IF in this case. While this is not very complicated to achieve on its own, the difficulty came when instructions began to affect other instructions. One instruction may change something in memory for an instruction immediately proceeding it, meaning that the pipeline must recognize when this can occur and inject empty instructions called NOOPs to stall the simulator in order for the memory to correctly affect the coming instruction. These types of problems were known as hazards, and each one called for a different solution such as port-forwarding or NOOP injection. This was definitely a worthwhile project to complete, but at the time was a major source of frustration and headaches. Each hazard that we needed to account for only presented more problems for our fixes for other hazards. While it was difficult to complete, it also was extremely helpful in understanding how a computer executes instructions.

Project 2: Cache Simulator - https://github.com/gudo1013/gudo1013/blob/57a4382fc2157465fe4df8c22b7888898340a59c/cache-simulator/README.md

The second project builds off a project done previously in the Computer Architecture class where we designed a single-cycle behavioral simulator. This project implements a cache system into that project. The project that it was built off of takes machine code and executes assembly language code. The accesses and data from the language program will be serviced by the cache. The cache we built essentially acted as a local memory point, reducing the number of calls to memory needed and increasing performance.
I think this project was one of the hardest projects I have ever done. There were various policies that we had to implement with different parameters that we needed to keep track of. I remember having many different nested if statements to determine when and where things had to go. 
This project and the previous pipelining project were very helpful in multiple ways, but these were also the projects where I learned the basics of C which is always a good thing to have another known language.

Project 3: Dynamic Web Server - https://github.com/gudo1013/dynamicserver/blob/f3185aa525292d89f956bdccdd25c7242ce0d547/README.md

The last computer science project I will be talking about is from the class Web Development. In this class, we were tasked with creating a dynamic website using data on energy in the US. This dynamic website differed from the static websites that we had previously developed by having only having a template for the html files that we were displaying.
In our static websites, the html was concrete and updates were made through JavaScript individually accessing elements and appending children or updating their content. For the dynamic website, we used a template for the data and dynamically updated the tables depending on what template and data was being shown. We also had to make sure that the site itself looked at least somewhat pleasing, so we implemented CSS to format the pages. 
This was a very in-depth application of many aspects of web-design that we had learned up until this point. In future projects, we dealt with some REST Api calling and using client-side frameworks, but this project utilized a lot of the basic skills used in creating websites. From understanding how to launch a server in the first place using node.js to using SQLite3 to access and query a database with specific requests. We also had to understand the asynchronous nature of JavaScript and use callbacks to ensure that data was being loaded in correctly. Lastly, we had to know how to write HTML files and CSS files that would dynamically update with the JavaScript we were using.
This project was definitely useful in design and understanding how websites are created. Useful in a lot of different situations down the road.

Project 4: Competitive Balance in the NBA

For this last project, it is outside the domain of computer science but takes into account my other major that I will be graduating with a degree in of Economics. I wanted to include this just as a final encapsulation of my time at St. Thomas. This essay was written with a partner, Colby Flynn, and we took a look at the competitive balance in the NBA through an empirical lens. There seems to be a lot of imbalance in the NBA with some teams dominating while others being left behind.
We took a look at a bunch of different factors that may go into why certain teams perform better. These factors include number of all-star players on a team, location, and amount paid in luxury taxes for going over the softcap of salary per team. We eventually found that the number of all-star players make a decisive difference to a team's winning percentage. Not suprising, but interesting to see that it had empirical support.
I think this paper was really interesting to research and write about, and definitely utilized a lot of different concepts that I learned about through my time studying Economics.
